``escape``
==========

Фільтр ``escape`` екранує рядок за допомогою стратегій, які залежать від контексту.

За замовчуванням використовується стратегія екранування HTML:

.. code-block:: html+twig

    <p>
        {{ user.username|escape }}
    </p>

Для зручності фільтр ``e`` визначено як псевдонім:

.. code-block:: html+twig

    <p>
        {{ user.username|e }}
    </p>

Фільтр ``escape`` також можна використовувати в інших контекстах, окрім HTML, завдяки
необов'язковому аргументу, який визначає стратегію екранування для використання:

.. code-block:: twig

    {{ user.username|e }}
    {# еквівалентно #}
    {{ user.username|e('html') }}

А ось як екранувати змінні, включені в код JavaScript:

.. code-block:: twig

    {{ user.username|escape('js') }}
    {{ user.username|e('js') }}

Фільтр ``escape`` підтримує наступні стратегії екранування для HTML-документів:

* ``html``: екранує рядок для контексту **тіла HTML**.

* ``js``: екранує рядок для контексту **JavaScript**.

* ``css``: екранує рядок для контексту **CSS**. Екранування CSS може бути застосовано
  до будь-якого рядка, що вставляється   в CSS, і екранує все, крім алфавітно-цифрових
  символів.

* ``url``: екранує рядок для контекстів **URI або параметра**. Не слід
  використовувати його для екранування цілого URI; вставляється лише підкомпонент.

* ``html_attr``: екранує рядок для контексту **HTML-атрибута**.

Зауважте, що контекстне екранування в HTML-документах є складним завданням, і вибір
правильної стратегії екранування залежить від багатьох факторів. Будь ласка, прочитайте відповідну
документацію, наприклад, `шпаргалку із запобігання OWASP <https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md>`_,
щоб дізнатися більше про цю тему.

.. note::

    Внутрішньо ``escape`` використовує нативну PHP-фунцію `htmlspecialchars`_ для
    стратегії екранування HTML.

.. caution::

    При використанні автоматичного екранування Twig намагається не допускати подвійного 
    екранування змінної якщо стратегія автоматичного екранування збігається зі стратегією,
    застосованою фільтром екранування; але це не працює при використанні змінної як стратегії
    екранування:

    .. code-block:: twig

        {% set strategy = 'html' %}

        {% autoescape 'html' %}
            {{ var|escape('html') }}   {# won't be double-escaped #}
            {{ var|escape(strategy) }} {# will be double-escaped #}
        {% endautoescape %}

    При використанні змінної як стратегії екранування слід вимкнути
    автоматичне екранування:

    .. code-block:: twig

        {% set strategy = 'html' %}

        {% autoescape 'html' %}
            {{ var|escape(strategy)|raw }} {# won't be double-escaped #}
        {% endautoescape %}

Користувацькі екранувальники
----------------------------

.. versionadded:: 3.10

    Клас ``EscaperRuntime`` було додано у версії 3.10. У попередніх версіях
    ви могли визначати власні екранувальники за допомогою виклику методу ``setEscaper()`` в
    екземплярі розширення екранувальника. Першим аргументом є стратегія екранування
    (яку буде використано у виклику ``escape``), а другим має бути коректне PHP-викличне::

        use Twig\Extension\EscaperExtension;

        $twig = new \Twig\Environment($loader);
        $twig->getExtension(EscaperExtension::class)->setEscaper('csv', 'csv_escaper');

    При виклику з Twig, викличне отримує екземпляр середовища Twig,
    рядок для екранування та набір символів.

Ви можете визначити користувацькі екранувальники за допомогою виклику методу ``setEscaper()`` 
в екземплярі виконання екранувальника. Він приймає два аргументи: назву стратегії та PHP,
який приймає рядок для екранування і набір символів::

    use Twig\Runtime\EscaperRuntime;

    $twig = new \Twig\Environment($loader);
    $escaper = fn ($string, $charset) => $string;
    $twig->getRuntime(EscaperRuntime::class)->setEscaper('identity', $escaper);

    # Використання в шаблоні:
    # {{ 'foo'|escape('identity') }}

.. note::

    Вбудовані екранувальники не можна перевизначати, головним чином тому, що їх слід 
    розглядати як остаточну реалізацію, а також для кращої продуктивності.

Аргументи
---------

* ``strategy``: Стратегія екранування
* ``charset``:  Набір символів рядка

.. _`htmlspecialchars`: https://www.php.net/htmlspecialchars
