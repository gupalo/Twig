``embed``
=========

Тег ``embed`` поєднує поведінку тегів :doc:`include<include>` та
:doc:`extends<extends>`. Він дозволяє додавати зміст іншого шаблону так само, як
це робить тег ``include``. Але він також дозволяє перевизначити будь-який блок,
визначений всередині доданого шаблону, як при розширенні шаблону.

Думайте про вбудований шаблон як про "скелет мікро-макета".

.. code-block:: twig

    {% embed "teasers_skeleton.twig" %}
        {# Ці блоки визначені в "teasers_skeleton.twig" #}
        {# і ми перевизначаємо їх прямо тут:                    #}
        {% block left_teaser %}
            Some content for the left teaser box
        {% endblock %}
        {% block right_teaser %}
            Some content for the right teaser box
        {% endblock %}
    {% endembed %}

Тег ``embed`` переносить ідею успадкування шаблону на рівень
фрагментів контенту. У той час як успадкування шаблонів дозволяє створювати "скелети документів", 
які наповнюються життям за допомогою дочірніх шаблонів, тег ``embed`` дозволяє вам
створювати "скелети" для менших одиниць змісту і повторно використовувати та наповнювати їх
де завгодно.

Оскільки варіант використання може бути неочевидним, давайте розглянемо спрощений приклад.
Уявіть собі базовий шаблон, спільний для декількох HTML-сторінок, який визначає один блок
під назвою "зміст":

.. code-block:: text

    ┌─── page layout ─────────────────────┐
    │                                     │
    │           ┌── block "content" ──┐   │
    │           │                     │   │
    │           │                     │   │
    │           │ (child template to  │   │
    │           │  put content here)  │   │
    │           │                     │   │
    │           │                     │   │
    │           └─────────────────────┘   │
    │                                     │
    └─────────────────────────────────────┘

Деякі сторінки ("foo" і "bar") мають однакову структуру змісту -
два вертикально розташовані поля:

.. code-block:: text

    ┌─── page layout ─────────────────────┐
    │                                     │
    │           ┌── block "content" ──┐   │
    │           │ ┌─ block "top" ───┐ │   │
    │           │ │                 │ │   │
    │           │ └─────────────────┘ │   │
    │           │ ┌─ block "bottom" ┐ │   │
    │           │ │                 │ │   │
    │           │ └─────────────────┘ │   │
    │           └─────────────────────┘   │
    │                                     │
    └─────────────────────────────────────┘

У той час як інші сторінки ("boom" і "baz") мають іншу структуру контенту -
два поля поруч:

.. code-block:: text

    ┌─── page layout ─────────────────────┐
    │                                     │
    │           ┌── block "content" ──┐   │
    │           │                     │   │    
    │           │ ┌ block ┐ ┌ block ┐ │   │
    │           │ │"left" │ │"right"│ │   │
    │           │ │       │ │       │ │   │
    │           │ │       │ │       │ │   │
    │           │ └───────┘ └───────┘ │   │
    │           └─────────────────────┘   │
    │                                     │
    └─────────────────────────────────────┘

Без тегу ``embed`` у вас є два способи створення шаблонів:

* Створити два "проміжні" базові шаблони, які розширюють основний макет
  шаблону: один з вертикально розташованими полями для використання на сторінках "foo" і
  "bar", а інший - з розташованими поруч полями для сторінок "boom" та
  «baz».

* Вбудувати розмітку для верхнього/нижнього та лівого/правого полів безпосередньо в 
  шаблон кожної сторінки.

Ці два рішення не дуже добре масштабуються, оскільки кожне з них має суттєвий недолік:

* Перше рішення дійсно може працювати для цього спрощеного прикладу. Але уявіть, що
  ми додаємо бічну панель, яка знову ж таки може містити різні, повторювані структури
  змісту. Тепер нам потрібно буде створити проміжні базові шаблони для  всіх можливих
  комбінацій структури змісту і структури бічної панелі... і так далі.

* Друге рішення передбачає дублювання загального коду з усіма негативними наслідками: 
  будь-яка зміна передбачає пошук і редагування всіх зачеплених копій
 структури, коректність має бути перевірена для кожної копії, копії можуть
 бути розсинхронізовані через необережні модифікації тощо.

У такій ситуації в нагоді стає тег ``embed``. Загальний макет
може жити в одному базовому шаблоні, а дві різні структури змісту,
назвемо їх "мікро-розмітки", знаходяться в окремих шаблонах, які вбудовуються
за необхідності:

Шаблон сторінки ``foo.twig``:

.. code-block:: twig

    {% extends "layout_skeleton.twig" %}

    {% block content %}
        {% embed "vertical_boxes_skeleton.twig" %}
            {% block top %}
                Some content for the top box
            {% endblock %}

            {% block bottom %}
                Some content for the bottom box
            {% endblock %}
        {% endembed %}
    {% endblock %}

А ось код для ``vertical_boxes_skeleton.twig``:

.. code-block:: html+twig

    <div class="top_box">
        {% block top %}
            Top box default content
        {% endblock %}
    </div>

    <div class="bottom_box">
        {% block bottom %}
            Bottom box default content
        {% endblock %}
    </div>

Мета шаблону ``vertical_boxes_skeleton.twig`` полягає в тому, щоб врахувати
HTML-розмітки для блоків.

Тег ``embed`` приймає ті самі аргументи, що й тег ``include``:

.. code-block:: twig

    {% embed "base" with {'foo': 'bar'} %}
        ...
    {% endembed %}

    {% embed "base" with {'foo': 'bar'} only %}
        ...
    {% endembed %}

    {% embed "base" ignore missing %}
        ...
    {% endembed %}

.. warning::

    Оскільки вбудовані шаблони не мають "імен", стратегії автоматичного екранування на основі
    імені шаблону не працюватимуть належним чином, якщо ви зміните контекст (наприклад, якщо
    ви вбудуєте CSS/JavaScript-шаблон в HTML-шаблон). У такому випадку явно встановіть стратегію
    автоматичного екранування за замовчуванням за допомогою тегу ``autoescape``.

.. seealso::

    :doc:`include<../tags/include>`
