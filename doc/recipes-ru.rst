Рецепты
=======

.. _deprecation-notices-ru:

Отображение уведомлений об устаревании
--------------------------------------

Устаревшие функции генерируют сообщение об устаревании (с помощью вызова
PHP-функции ``trigger_error()`` ). По умолчанию они отключаются и никогда не
не отображаются и не записываются в лог.

Чтобы удалить все устаревшие функции из ваших шаблонов, напишите и запустите скрипт
примерно такого вида::

    require_once __DIR__.'/vendor/autoload.php';

    $twig = create_your_twig_env();

    $deprecations = new \Twig\Util\DeprecationCollector($twig);

    print_r($deprecations->collectDir(__DIR__.'/templates'));

Метод ``collectDir()`` компилирует все шаблоны, найденные в каталоге, отлавливает сообщения
об устаревании и возвращает их.

.. tip::

    Если ваши шаблоны не хранятся в файловой системе, используйте метод 
    ``collect()`` вместо этого. ``collect()`` принимает ``Traversable``, который должен вернуть
    имена шаблонов как ключи и содержание шаблонов как значения (как это делается с помощью
    ``\Twig\Util\TemplateDirIterator``).

Однако, этот код не найдет всех устареваний (например, использование некоторых устаревших классов
Twig). Чтобы отлавливать все уведомления, зарегистрируйте пользовательский обработчик ошибок, такой как 
вроде того, что приведено ниже::

    $deprecations = [];
    set_error_handler(function ($type, $msg) use (&$deprecations) {
        if (E_USER_DEPRECATED === $type) {
            $deprecations[] = $msg;
        }
    });

    // запустите ваше приложение

    print_r($deprecations);

Обратите внимание, что большинство уведомлений об устаревании срабатывают во время **компиляции**, поэтому 
они не будут сгенерированы, когда шаблоны уже кешированы.

.. tip::

    Если вы хотите управлять уведомлениями об устаревании в ваших тестах PHPUnit, 
    взгляните на пакет `symfony/phpunit-bridge <https://github.com/symfony/phpunit-bridge>`_,
    который облегчает процесс.

Делаем макет условным
---------------------

Работа с Ajax означает, что одно и то же содержание иногда отображается как есть,
а иногда украшается макетом. Поскольку именами шаблонов макетов Twig могут быть
любые допустимые выражения, вы можете передать переменную, которая получит значение ``true``, когда
запрос сделан через Ajax, и в соответствии с этим выбрать макет:

.. code-block:: twig

    {% extends request.ajax ? "base_ajax.html" : "base.html" %}

    {% block content %}
        Это содержание для отображения.
    {% endblock %}

Делаем включение динамическим
-----------------------------

При включении шаблона его имя не обязательно должно быть строкой. Например, название
может зависеть от значения переменной:

.. code-block:: twig

    {% include var ~ '_foo.html' %}

Если ``var`` оценивается как ``index``, будет отображен шаблон ``index_foo.html``.

На самом деле, имя шаблона может быть любым валидным выражением, например
следующим:

.. code-block:: twig

    {% include var|default('index') ~ '_foo.html' %}

Переопределение шаблона, который также расширяется
--------------------------------------------------

Шаблон можно настроить двумя различными способами:

* *Наследование*: Шаблон *расширяет* родительский шаблон и переопределяет некоторые
  блоки;

* *Замена*: Если вы используете загрузчик файловой системы, Twig загружает первый
  шаблон, который он найдет в списке сконфигурированных каталогов; шаблон, найденный в каталоге,
  *заменяет* другой шаблон из каталога, расположенного дальше в списке.

Но как совместить оба варианта: *заменить* шаблон, который также расширяется
(то есть, шаблон в каталоге, расположенном дальше в списке)?

Предположим, что ваши шаблоны загружаются как из папки ``.../templates/mysite``, так и 
из папки ``.../templates/default`` в таком порядке. Шаблон ``page.twig``,
хранящийся в ``.../templates/default``, читается следующим образом:

.. code-block:: twig

    {# page.twig #}
    {% extends "layout.twig" %}

    {% block content %}
    {% endblock %}

Вы можете заменить этот шаблон, поместив файл с таким же именем в папку ``.../templates/mysite``.
А если вы хотите расширить оригинальный шаблон, вам может захотеться написать следующее:

.. code-block:: twig

    {# page.twig in .../templates/mysite #}
    {% extends "page.twig" %} {# from .../templates/default #}

Однако, это не будет работать, так как Twig всегда будет загружать шаблон из
``.../templates/mysite``.

Оказывается, можно заставить это работать, добавив каталог прямо в конце ваших каталогов шаблонов,
который является родительским для всех остальных каталогов: ``.../templates`` в нашем случае. Это 
приведет к тому, что сделает каждый файл шаблона в нашей системе уникально адресуемым. Большую часть
времени вы будете использовать "нормальные" пути, но в особых случаях, когда вы захотите расширить
шаблон с переопределенной версией самого шаблона, мы можем сослаться на на его полный, однозначный
путь к шаблону в теге расширения:

.. code-block:: twig

    {# page.twig in .../templates/mysite #}
    {% extends "default/page.twig" %} {# from .../templates #}

.. note::

    Этот рецепт был вдохновлен следующей вики-страницей Django:
    https://code.djangoproject.com/wiki/ExtendingTemplates

Настройка синтаксиса
--------------------

Twig позволяет некоторую настройку синтаксиса для разделителей блоков. Не рекомендуется
использовать эту возможность, поскольку шаблоны будут привязаны к вашему пользовательскому
синтаксису. Но для определенных проектов может иметь смысл изменить значение по умолчанию.

Чтобы изменить разделители блоков, вам нужно создать собственный объект лексера::

    $twig = new \Twig\Environment(...);

    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'   => ['{#', '#}'],
        'tag_block'     => ['{%', '%}'],
        'tag_variable'  => ['{{', '}}'],
        'interpolation' => ['#{', '}'],
    ]);
    $twig->setLexer($lexer);

Ниже приведен пример конфигурации, имитирующей некоторый другой синтексис движка шаблонов::

    // Синтаксис Ruby erb
    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'  => ['<%#', '%>'],
        'tag_block'    => ['<%', '%>'],
        'tag_variable' => ['<%=', '%>'],
    ]);

    // Синтаксис SGML Comment
    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'  => ['<!--#', '-->'],
        'tag_block'    => ['<!--', '-->'],
        'tag_variable' => ['${', '}'],
    ]);

    // Похожий на Smarty
    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'  => ['{*', '*}'],
        'tag_block'    => ['{', '}'],
        'tag_variable' => ['{$', '}'],
    ]);

Использование динамических свойств объекта
------------------------------------------

Когда Twig встречает переменную типа ``article.title``, он пытается найти в объекте 
``article`` публичное свойство ``title``.

Это также работает, если свойство не существует, а определяется динамически,
благодаря волшебному методу ``__get()``; вам также нужно реализовать волшебный метод
``__isset()``, как показано в следующем фрагменте кода::

    class Article
    {
        public function __get($name)
        {
            if ('title' == $name) {
                return 'The title';
            }

            // вызвать какую-то ошибку
        }

        public function __isset($name)
        {
            if ('title' == $name) {
                return true;
            }

            return false;
        }
    }

Доступ к родительскому контексту во вложенных циклах
----------------------------------------------------

Иногда при использовании вложенных циклов вам нужно получить доступ к родительскому
контексту. Родительский контекст всегда доступен через переменную ``loop.parent``. Например,
если у вас есть следующие данные шаблона::

    $data = [
        'topics' => [
            'topic1' => ['Message 1 of topic 1', 'Message 2 of topic 1'],
            'topic2' => ['Message 1 of topic 2', 'Message 2 of topic 2'],
        ],
    ];

И следующий шаблон для отображения всех сообщений во всех темах:

.. code-block:: twig

    {% for topic, messages in topics %}
        * {{ loop.index }}: {{ topic }}
      {% for message in messages %}
          - {{ loop.parent.loop.index }}.{{ loop.index }}: {{ message }}
      {% endfor %}
    {% endfor %}

Вывод будет похожим на:

.. code-block:: text

    * 1: topic1
      - 1.1: Сообщение 1 темы 1
      - 1.2: Сообщение 2 темы 1
    * 2: topic2
      - 2.1: Сообщение 1 темы 2
      - 2.2: Сообщение 2 темы 2

Во внутреннем цикле переменная ``loop.parent`` используется для доступа к внешнему
контексту. Следовательно, индекс текущей ``topic``, определенный снаружи для цикла, доступен через
переменную ``loop.parent.loop.index``.

Определение неопределенных функций, фильтров и тегов на ходу
------------------------------------------------------------

.. versionadded:: 3.2

    Метод ``registerUndefinedTokenParserCallback()`` был представлен в Twig
    3.2.

Если функция/фильтр/тег не определены, по умолчанию Twig вызывает исключение
``\Twig\Error\SyntaxError``. Однако, он также может вызвать `callback`_(любое
допустимое PHP-вызываемое), которое должно вернуть функцию/фильтр/тег.

Для тегов регистрируйте обратные вызовы с помощью ``registerUndefinedTokenParserParserCallback()``.
Для фильтров зарегистрируйте обратные вызовы с помощью ``registerUndefinedFilterCallback()``.
Для функций используйте ``registerUndefinedFunctionCallback()``::

    // автоматически регистрировать все нативные функции PHP как функции Twig
    // НИКОГДА не делайте этого в проекте, так как это НЕ безопасно
    $twig->registerUndefinedFunctionCallback(function ($name) {
        if (function_exists($name)) {
            return new \Twig\TwigFunction($name, $name);
        }

        return false;
    });

Если вызывающее не может вернуть корректную функцию/фильтр/тег, оно должно
вернуть ``false``.

Если вы зарегистрируете более одного обратного вызова, Twig будет вызывать их по очереди,
пока один из них не вернет ``false``.

.. tip::

    Поскольку решение функций/фильтров/тегов происходит во время компиляции,
    регистрация этих обратных вызовов не влечет никаких дополнительных затрат.

Валидация синтаксиса шаблона
----------------------------

Когда код шаблона предоставляется третьей стороной (например, через веб-интерфейс), может быть
полезно проверить синтаксис шаблона перед его сохранением. Если код шаблона сохраняется
в переменной ``$template``, вот как это можно сделать::

    try {
        $twig->parse($twig->tokenize(new \Twig\Source($template)));

        // $template является валидным
    } catch (\Twig\Error\SyntaxError $e) {
        // $template содержит одну или более ошибок синтаксиса
    }

Если вы выполняете итерацию по набору файлов, вы можете передать имя файла методу
``tokenize()``, чтобы получить имя файла в сообщении исключения::

    foreach ($files as $file) {
        try {
            $twig->parse($twig->tokenize(new \Twig\Source($template, $file->getFilename(), $file)));

            // $template является валидным
        } catch (\Twig\Error\SyntaxError $e) {
            // $template содержит одну или более ошибок синтаксиса
        }
    }

.. note::

    Этот метод не обнаружит никаких нарушений политики песочницы, поскольку политика
    применяется во время отображения шаблона (так как Twig требует контекста для
    некоторых проверок, таких как разрешенные методы в объектах).

Обновление измененных шаблонов при включенном OPcache
-----------------------------------------------------

При использовании OPcache с ``opcache.validate_timestamps``, установленным в значение ``0``,
включен кеш Twig и отключена автоматическая перезагрузка, что очищает кеш шаблона, и он
не будет обновляться.

Чтобы обойти это, заставьте Twig сделать кеш байт-кода невалидным::

    $twig = new \Twig\Environment($loader, [
        'cache' => new \Twig\Cache\FilesystemCache('/some/cache/path', \Twig\Cache\FilesystemCache::FORCE_BYTECODE_INVALIDATION),
        // ...
    ]);

Повторное использование посетителя узла с состоянием
----------------------------------------------------

При присоединении посетителя к экземпляру ``\Twig\Environment``, Twig использует его
для посещения *всех* шаблонов, которые он компилирует. Если вам нужно сохранить некоторую
информацию о состоянии, вы, вероятно, захотите обнулять ее при посещении нового шаблона.

Этого можно добиться с помощью следующего кода::

    protected $someTemplateState = [];

    public function enterNode(\Twig\Node\Node $node, \Twig\Environment $env)
    {
        if ($node instanceof \Twig\Node\ModuleNode) {
            // обнулить состояние, так как мы входим в новый шаблон
            $this->someTemplateState = [];
        }

        // ...

        return $node;
    }

Использование базы данных для хранения шаблонов 
-----------------------------------------------

Если вы разрабатываете CMS, шаблоны обычно хранятся в базе данных. Этот рецепт 
дает вам простой загрузчик шаблонов PDO, который вы можете использовать в качестве отправной точки для своего собственного.

Сначала создадим временную базу данных SQLite3 в памяти для работы::

    $dbh = new PDO('sqlite::memory:');
    $dbh->exec('CREATE TABLE templates (name STRING, source STRING, last_modified INTEGER)');
    $base = '{% block content %}{% endblock %}';
    $index = '
    {% extends "base.twig" %}
    {% block content %}Hello {{ name }}{% endblock %}
    ';
    $now = time();
    $dbh->prepare('INSERT INTO templates (name, source, last_modified) VALUES (?, ?, ?)')->execute(['base.twig', $base, $now]);
    $dbh->prepare('INSERT INTO templates (name, source, last_modified) VALUES (?, ?, ?)')->execute(['index.twig', $index, $now]);

Мы создали простую таблицу ``templates``, которая содержит два шаблона:
``base.twig`` и ``index.twig``.

Теперь давайте определим загрузчик, который может использовать эту базу данных:: 

    class DatabaseTwigLoader implements \Twig\Loader\LoaderInterface
    {
        protected $dbh;

        public function __construct(PDO $dbh)
        {
            $this->dbh = $dbh;
        }

        public function getSourceContext(string $name): Source
        {
            if (false === $source = $this->getValue('source', $name)) {
                throw new \Twig\Error\LoaderError(sprintf('Template "%s" does not exist.', $name));
            }

            return new \Twig\Source($source, $name);
        }

        public function exists(string $name)
        {
            return $name === $this->getValue('name', $name);
        }

        public function getCacheKey(string $name): string
        {
            return $name;
        }

        public function isFresh(string $name, int $time): bool
        {
            if (false === $lastModified = $this->getValue('last_modified', $name)) {
                return false;
            }

            return $lastModified <= $time;
        }

        protected function getValue($column, $name)
        {
            $sth = $this->dbh->prepare('SELECT '.$column.' FROM templates WHERE name = :name');
            $sth->execute([':name' => (string) $name]);

            return $sth->fetchColumn();
        }
    }

Наконец, вот пример того, как вы можете это использовать::

    $loader = new DatabaseTwigLoader($dbh);
    $twig = new \Twig\Environment($loader);

    echo $twig->render('index.twig', ['name' => 'Fabien']);

Использование различных источников шаблонов
-------------------------------------------

Этот рецепт является продолжением предыдущего. Даже если вы сохраняете отправленные шаблоны в
базе данных, вы, возможно, захотите сохранить оригинальные/базовые шаблоны в файловой системе.
Если шаблоны можно загружать из разных источников, вам следует воспользоваться загрузчиком 
``\Twig\Loader\ChainLoader``.

Как вы можете видеть в предыдущем рецепте, мы ссылаемся на шаблон так же, как это было бы
бы сделано с помощью обычного загрузчика файловой системы. Это является ключом к возможности
смешивать различные шаблоны, поступающие из базы данных, файловой системы или любого другого
загрузчика: имя шаблона должно быть логическим именем, а не путем из файловой системы::

    $loader1 = new DatabaseTwigLoader($dbh);
    $loader2 = new \Twig\Loader\ArrayLoader([
        'base.twig' => '{% block content %}{% endblock %}',
    ]);
    $loader = new \Twig\Loader\ChainLoader([$loader1, $loader2]);

    $twig = new \Twig\Environment($loader);

    echo $twig->render('index.twig', ['name' => 'Fabien']);

Теперь, когда шаблоны ``base.twig`` определены в загрузчике массива, вы можете
удалить его из базы данных, и все остальное будет работать как и раньше.

Загрузка шаблона из строки
--------------------------

Из шаблона можно загрузить шаблон, хранящийся в строке, с помощью функции
``template_from_string`` (через расширение ``\Twig\Extension\StringLoaderExtension``):

.. code-block:: twig

    {{ include(template_from_string("Hello {{ name }}")) }}

Из PHP также можно загрузить шаблон, сохраненный в виде строки, с помощью
``\Twig\Environment::createTemplate()``::

    $template = $twig->createTemplate('hello {{ name }}');
    echo $template->render(['name' => 'Fabien']);

Использование Twig и AngularJS в одном шаблоне
----------------------------------------------

Смешивание разных синтаксисов шаблонов в одном файле не рекомендуется,
поскольку AngularJS и Twig используют одинаковые разделители в своем синтаксисе:
``{{`` и ``}}``.

Однако, если вы хотите использовать AngularJS и Twig в одном шаблоне, есть
два способа сделать так, чтобы это работало, в зависимости от количества AngularJS,
которое вам нужно добавить в ваши шаблоны:

* Экранирование разделителей AngularJS путем обертывания разделов AngularJS тегом
  ``{% verbatim %}`` или экранированием каждого разделителя через ``{{ '{{' }}`` и
  ``{{ '}}' }}``;

* Изменение разделителей одного из движков шаблонов (в зависимости от того, какой из них вы ввели
  последним):

  * Для AngularJS, измените теги интерполяции, используя сервис
    ``interpolateProvider``, например, во время инициализации модуля:

    .. code-block:: javascript

        angular.module('myApp', []).config(function($interpolateProvider) {
            $interpolateProvider.startSymbol('{[').endSymbol(']}');
        });

  * Для Twig, измените разделители через опцию лексера ``tag_variable``::

        $env->setLexer(new \Twig\Lexer($env, [
            'tag_variable' => ['{[', ']}'],
        ]));

Обозначение узла как безопасного
--------------------------------

При использовании расширения экранирования вы можете пометить некоторые узлы 
как безопасные, чтобы избежать любого экранирования. Вы можете сделать это, обернув
ваше выражение с помощью узла ``RawFilter``::

    use Twig\Node\Expression\Filter\RawFilter;

    $safeExpr = new RawFilter(new YourSafeNode());

.. _callback: https://www.php.net/manual/en/function.is-callable.php
