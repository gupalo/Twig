Twig для розробників
====================

Ця глава описує API до Twig, а не мову шаблонів. Вона буде найбільш корисною
як довідник для тих, хто реалізує інтерфейс шаблонів у додатку, а не для тих,
хто створює шаблони Twig.

Основи
------

Twig використовує центральний об'єкт, який називається **середовище** (класу
``\Twig\Environment``). Екземпляри цього класу використовуються для зберігання
конфігурації та розширень, а також для завантаження шаблонів.

Більшість додатків створюють один об'єкт ``\Twig\Environment`` під час ініціалізації
додатку і використовують його для завантаження шаблонів. У деяких випадках може бути
корисно мати декілька оточень пліч-о-пліч з різними конфігураціями.

Типовий спосіб конфігурації Twig для завантаження шаблонів для додатку виглядає
приблизно так::

    require_once '/path/to/vendor/autoload.php';

    $loader = new \Twig\Loader\FilesystemLoader('/path/to/templates');
    $twig = new \Twig\Environment($loader, [
        'cache' => '/path/to/compilation_cache',
    ]);

Це створить середовище шаблонів з конфігурацією за замовчуванням і завантажувачем
який шукає шаблони у каталозі ``/path/to/templates/``. Доступні різні завантажувачі,
і ви також можете написати свій власний, якщо ви хочете завантажувати шаблони з бази
даних або інших джерел.

.. note::

    Зверніть увагу, що другим аргументом середовища є масив опцій.
    Опція ``cache`` - це каталог кешу компіляції, куди Twig кешує
    скомпільовані шаблони, щоб уникнути фази аналізу для наступних
    запитів. Це дуже відрізняється від кешу, який ви можете додати для
    для шаблонів, що обробляються. Для такої потреби ви можете використовувати
    будь-яку доступну бібліотеку кешу PHP.

Відображення шаблонів
---------------------

Щоб завантажити шаблон з середовища Twig, викличте метод ``load()``, який
повертає екземпляр ``\Twig\TemplateWrapper``::

    $template = $twig->load('index.html');

Щоб відобразити шаблон з деякими змінними, викличте метод ``render()``::

    echo $template->render(['the' => 'variables', 'go' => 'here']);

.. note::

    Метод ``display()`` є скороченням для виведення відображеного шаблону.

Ви також можете завантажити та відобразити шаблон одним махом::

    echo $twig->render('index.html', ['the' => 'variables', 'go' => 'here']);

Якщо шаблон визначає блоки, їх можна відобразити окремо за допомогою виклику
``renderBlock()``::

    echo $template->renderBlock('block_name', ['the' => 'variables', 'go' => 'here']);

.. _environment_options-uk:

Опції середовища
----------------

При створенні нового екземпляру ``\Twig\Environment`` ви можете передати масив опцій в
якості другого аргумента конструктора::

    $twig = new \Twig\Environment($loader, ['debug' => true]);

Доступні наступні опції:

* ``debug`` *булеве значення*

  Коли встановлено як ``true``, згенеровані шаблони мають метод
  ``__toString()``, який ви можете використовувати для відображення
  згенерованих вузлів (за замовчуванням ``false``).

* ``charset`` *рядок* (за замовчуванням - ``utf-8``)

  Набір символів, що використовується шаблонами.

* ``cache`` *рядок* або ``false``

  Абсолютний шлях, де зберігати скомпільовані шаблони, або
  ``false`` для вимкнення кешування (за замовчуванням).

* ``auto_reload`` *булеве значення*

  При розробці за допомогою Twig корисно повторно компілювати шаблон щоразу,
  коли змінюється вихідний код. Якщо ви не вкажете значення для опції 
  ``auto_reload``, воно буде визначено автоматично на основі значення
  ``debug``.

.. _environment_options_strict_variables-uk:

* ``strict_variables`` *булеве значення*

  Якщо встановлено у значення ``false``, Twig буде мовчки ігнорувати невалідні
  змінні (змінні та/або атрибути/методи, яких не існує) і замінюватиме їх значенням
  ``null``. Якщо встановлено значення ``true``, Twig викличе виключення (за 
  замовчуванням ``false``).

* ``autoescape`` *рядок*

  Встановлює стратегію авто-екранування за замовчуванням (``name``, ``html``, ``js``,
  ``css``, ``url``, ``html_attr``, або зворотний виклик PHP, який приймає "filename" шаблону 
  і повертає стратегію екранування для використання - зворотний виклик не може бути імʼям 
  функції, щоб уникнути зіткнення з вбудованими стратегіями екранування); встановіть значення
  ``false``, щоб вимкнути автоматичне екранування. Стратегія екранування ``name`` визначає
  стратегію екранування для шаблону на основі розширення імені файлу шаблону
  (ця стратегія не спричиняє жодних додаткових витрат під час виконання, оскільки
  автоматичне екранування виконується під час компіляції).

* ``optimizations`` *ціле число*

  Прапорець, який вказує, які оптимізації застосовувати (за замовчуванням ``-1``
  - усі оптимізації ввімкнено; встановіть ``0`` для того, щоб їх вимкнути).

Завантажувачі
-------------

Завантажувачі відповідають за завантаження шаблонів з таких джерел, як файлова система.

Кеш компіляції
~~~~~~~~~~~~~~

Усі завантажувачі шаблонів можуть кешувати скомпільовані шаблони у файловій системі для 
подальшого використання. Це значно пришвидшує роботу Twig, оскільки шаблони компілюються
лише один раз.

Вбудовані завантажувачі
~~~~~~~~~~~~~~~~~~~~~~~

Ось список вбудованих завантажувачів:

``\Twig\Loader\FilesystemLoader``
.................................

``\Twig\Loader\FilesystemLoader`` завантажує шаблони з файлової системи. Цей завантажувач
може знаходити шаблони у папках файлової системи і є бажаним способом їх завантаження::

    $loader = new \Twig\Loader\FilesystemLoader($templateDir);

Він також може шукати шаблони в масиві каталогів::

    $loader = new \Twig\Loader\FilesystemLoader([$templateDir1, $templateDir2]);

З такою конфігурацією Twig спочатку шукатиме шаблони у ``$templateDir1``, і якщо
вони не існують, то буде шукати їх у ``$templateDir2``.

Ви можете додавати або змінювати шляхи за допомогою методів ``addPath()`` та ``prependPath()``::


    $loader->addPath($templateDir3);
    $loader->prependPath($templateDir4);

Завантажувач файлової системи також підтримує шаблони з простором імен. Це дозволяє групувати
ваші шаблони у різних просторах імен, які мають власні шляхи до шаблонів.

При використанні методів ``setPaths()``, ``addPath()`` і ``prependPath()``, вкажіть простір
імен як другий аргумент (якщо його не вказано, ці методи працюють з «основним» простором імен)::

    $loader->addPath($templateDir, 'admin');

До шаблонів з простором імен можна отримати доступ через спеціальну нотацію
``@namespace_name/template_path``::

    $twig->render('@admin/index.html', []);

``\Twig\Loader\FilesystemLoader`` підтримує абсолютні та відносні шляхи. Використання відносних
шляхів є кращим, оскільки це робить ключі кешу незалежними від кореневого каталогу проекту
(наприклад, це дозволяє прогрівати кеш з сервера збірки, де каталог може відрізнятися від того,
що використовується на  серверах виробництва)::

    $loader = new \Twig\Loader\FilesystemLoader('templates', getcwd().'/..');

.. note::

    Якщо не передавати кореневий шлях як другий аргумент, Twig використовує ``getcwd()``
    для відносних шляхів.

``\Twig\Loader\ArrayLoader``
............................

``\Twig\Loader\ArrayLoader`` завантажує шаблон з масиву PHP. Йому передається
масив рядків, прив'язаних до назв шаблонів::

    $loader = new \Twig\Loader\ArrayLoader([
        'index.html' => 'Hello {{ name }}!',
    ]);
    $twig = new \Twig\Environment($loader);

    echo $twig->render('index.html', ['name' => 'Fabien']);

Цей завантажувач дуже корисний для модульного тестування. Він також може бути використаний
для невеликих проектів, де зберігання всіх шаблонів в одному PHP-файлі може мати сенс. 

.. tip::

    При використанні завантажувача ``Array`` з механізмом кешування слід знати, що
    новий ключ кешу генерується кожного разу, коли зміст шаблону "змінюється" (ключ кешу
    є вихідним кодом шаблону). Якщо ви не хочете, щоб ваш кеш вийшов з-під контролю, вам
    потрібно подбати про очищення старого файлу кешу самостійно.

``\Twig\Loader\ChainLoader``
............................

``\Twig\Loader\ChainLoader`` делегує завантаження шаблонів іншим завантажувачам::

    $loader1 = new \Twig\Loader\ArrayLoader([
        'base.html' => '{% block content %}{% endblock %}',
    ]);
    $loader2 = new \Twig\Loader\ArrayLoader([
        'index.html' => '{% extends "base.html" %}{% block content %}Hello {{ name }}{% endblock %}',
        'base.html'  => 'Will never be loaded',
    ]);

    $loader = new \Twig\Loader\ChainLoader([$loader1, $loader2]);

    $twig = new \Twig\Environment($loader);

Шукаючи шаблон, Twig пробує кожен завантажувач по черзі і повертається, як тільки
шаблон буде знайдено. Під час відображення шаблону ``index.html`` з наведеного вище
прикладу, Twig завантажить його за допомогою ``$loader2``, але шаблон ``base.html``
буде завантажено з ``$loader1``.

.. note::

    Ви також можете додавати завантажувачі через метод ``addLoader()``.

Створіть ваш власний завантажувач
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Всі завантажувачі реалізують ``\Twig\Loader\LoaderInterface``::

    interface \Twig\Loader\LoaderInterface
    {
        /**
         * Повертає контекст джерела для заданого логічного імені шаблону.
         *
         * @param string $name Логічне імʼя шаблону
         *
         * @return \Twig\Source
         *
         * @throws \Twig\Error\LoaderError Коли $name не знайдено
         */
        public function getSourceContext($name);

        /**
         * Отримує ключ кешу для використання для кешу заданого імені шаблону.
         *
         * @param string $name Імʼя шаблону для завантаження
         *
         * @return string Ключ кешу
         *
         * @throws \Twig\Error\LoaderError Коли $name не знайдено
         */
        public function getCacheKey($name);

        /**
         * Повертає true, якщо шаблон все ще свіжий.
         *
         * @param string    $name Імʼя шаблону
         * @param timestamp $time Час останньої модифікації кешованого шаблону
         *
         * @return bool    true, якщо шаблон свіжий, false - в іншому випадку
         *
         * @throws \Twig\Error\LoaderError Коли $name не знайдено
         */
        public function isFresh($name, $time);

        /**
         * Перевірити, чи у нас є вихідний код шаблону, маючи його імʼя.
         *
         * @param string $name Імʼя шаблону для перевірки того, чи можемо ми його завантажити
         *
         * @return bool    Чи обробляється вихідний код шаблону завантажувачем
         */
        public function exists($name);
    }

Метод ``isFresh()`` повинен повертати ``true``, якщо поточний кешований шаблон
все ще свіжий, враховуючи час останньої модифікації, або ``false`` в іншому випадку.

Метод ``getSourceContext()`` повинен повертати екземпляр ``\Twig\Source``.

Використання розширень
----------------------

Розширення Twig - це пакети, які додають нові можливості до Twig. Зареєструйте розширення
за допомогою методу ``addExtension()``::

    $twig->addExtension(new \Twig\Extension\SandboxExtension());

Twig постачається з наступними розширеннями:

* *Twig\Extension\CoreExtension*: Визначає всі основні функції Twig.

* *Twig\Extension\DebugExtension*: Визначає функцію ``dump``, щоб допомогти з налагодженням
  змінних шаблону.

* *Twig\Extension\EscaperExtension*: Додає автоматичне екранування виведення та можливість
  екранувати/не екранувати блоки коду.

* *Twig\Extension\SandboxExtension*: Додає режим пісочниці до середовища Twig за замовчуванням,
  що робить оцінку ненадійного коду безпечною.

* *Twig\Extension\ProfilerExtension*: Включає вбудований профілювальник Twig.

* *Twig\Extension\OptimizerExtension*: Оптимізує дерево вузлів перед компіляцією.

* *Twig\Extension\StringLoaderExtension*: Визначає функцію ``template_from_string``, щоб
  дозволити завантажувати шаблоні з рядку у шаблоні.

Розширення Core, Escaper, та Optimizer реєструються за замовчуванням.

Вбудовані розширення
--------------------

Цей розділ описує функції, що додаються вбудованими розширеннями.

.. tip::

    Прочитайте главу про :doc:`розширення Twig <advanced>`, щоб дізнатися, як
    створювати ваші власні розширення.

Основні розширення
~~~~~~~~~~~~~~~~~~

``core`` Розширення визначає усі основні функції Twig:

* :doc:`Теги <tags/index>`;
* :doc:`Фільтри <filters/index>`;
* :doc:`Функції <functions/index>`;
* :doc:`Тести <tests/index>`.

Розширення Escaper
~~~~~~~~~~~~~~~~~~

Розширення ``escaper`` додає до Twig автоматичне екранування виводу. Воно визначає тег
тег ``autoescape`` і фільтр ``raw``.

При створенні розширення екранування ви можете увімкнути або вимкнути глобальну
стратегію екранування виведення::

    $escaper = new \Twig\Extension\EscaperExtension('html');
    $twig->addExtension($escaper);

Якщо встановлено у значення ``html``, усі змінні у шаблонах екрануються (за допомогою
стратегії екранування ``html``), окрім тих, що використовують фільтр ``raw``:

.. code-block:: twig

    {{ article.to_html|raw }}

Ви також можете змінити режим екранування локально за допомогою тегу ``autoescape``:

.. code-block:: twig

    {% autoescape 'html' %}
        {{ var }}
        {{ var|raw }}      {# var won't be escaped #}
        {{ var|escape }}   {# var won't be double-escaped #}
    {% endautoescape %}

.. warning::

    Тег ``autoescape`` не має жодного ефекту на включені файли.

Правила екранування реалізовані наступним чином:

* Літерали (цілі числа, булеві, масиви, ...), що використовуються в шаблоні безпосередньо як
  як змінні або аргументи фільтрів, ніколи не екрануються автоматично:

  .. code-block:: html+twig

        {{ "Twig<br/>" }} {# не буде екрановано #}

        {% set text = "Twig<br/>" %}
        {{ text }} {# will be escaped #}

* Вирази, результатом яких є літерал або змінна, позначені безпечними, 
  ніколи не екрануються автоматично:

  .. code-block:: html+twig

        {{ foo ? "Twig<br/>" : "<br/>Twig" }} {# won't be escaped #}

        {% set text = "Twig<br/>" %}
        {{ true ? text : "<br/>Twig" }} {# буде екрановано #}
        {{ false ? text : "<br/>Twig" }} {# не буде екрановано #}

        {% set text = "Twig<br/>" %}
        {{ foo ? text|raw : "<br/>Twig" }} {# не буде екрановано #}

* Об'єкти з методом ``__toString`` конвертуються в рядки і 
  екрануються. Ви можете позначити деякі класи та/або інтерфейси як безпечні для деяких
  стратегій за допомогою ``EscaperExtension::addSafeClass()``:

  .. code-block:: twig

        // позначити обʼєкт класу Foo як безпесний для стратегії HTML
        $escaper->addSafeClass('Foo', ['html']);

        // позначити обʼєкт інтерфейсу Foo як безпечний для стратегії HTML
        $escaper->addSafeClass('FooInterface', ['html']);

        // позначити обʼєкт класу Foo як безпечний для стратегій HTML та JS
        $escaper->addSafeClass('Foo', ['html', 'js']);

        // позначити обʼєкт класу Foo як безпечний для всіх стратегій
        $escaper->addSafeClass('Foo', ['all']);

* Екранування застосовується перед виведенням, після застосування будь-якого іншого фільтра:

  .. code-block:: twig

        {{ var|upper }} {# is equivalent to {{ var|upper|escape }} #}

* Фільтр ``raw`` слід використовувати лише в кінці ланцюжка фільтрів:

  .. code-block:: twig

        {{ var|raw|upper }} {# will be escaped #}

        {{ var|upper|raw }} {# won't be escaped #}

* Автоматичне екранування не застосовується, якщо останній фільтр у ланцюжку позначено
  безпечним для поточного контексту (наприклад, ``html`` або ``js``). ``escape`` і
  ``escape('html')`` позначені як безпечні для HTML, ``escape('js')`` позначений
  безпечним для JavaScript, ``raw`` - безпечним для всього.

  .. code-block:: twig

        {% autoescape 'js' %}
            {{ var|escape('html') }} {# буде екрановано для HTML та JavaScript #}
            {{ var }} {# буде екрановано для JavaScript #}
            {{ var|escape('js') }} {# не буде подвійно екрановано #}
        {% endautoescape %}

.. note::

    Зауважте, що автоматичне екранування має деякі обмеження, оскільки екранування застосовується у
    виразах після обчислення. Наприклад, при роботі з конкатенацією, ``{{ foo|raw ~ bar }}`` не дасть
    очікуваного результату, оскільки екранування застосовується до результату конкатенації, а не до
    окремих змінних (отже, фільтр ``raw`` тут не матиме жодного ефекту).

Розширення Sandbox
~~~~~~~~~~~~~~~~~~

Розширення ``sandbox`` можна використовувати для оцінки ненадійного коду. Доступ до
небезпечних атрибутів та методів заборонено. Безпекою пісочниці керує
екземпляр політики. За замовчуванням Twig постачається з одним класом політики:
``\Twig\Sandbox\SecurityPolicy``. Цей клас дозволяє вам вносити до білого списку деякі
теги, фільтри, функції, властивості та методи::

    $tags = ['if'];
    $filters = ['upper'];
    $methods = [
        'Article' => ['getTitle', 'getBody'],
    ];
    $properties = [
        'Article' => ['title', 'body'],
    ];
    $functions = ['range'];
    $policy = new \Twig\Sandbox\SecurityPolicy($tags, $filters, $methods, $properties, $functions);

У попередній конфігурації політика безпеки дозволятиме використання лише
тегу ``if`` та фільтра ``upper``. Крім того, шаблони зможуть 
викликати методи ``getTitle()`` і ``getBody()`` лише в об'єктах ``Article``, а
також публічних властивостях ``title`` і ``body``. Все інше буде заборонено і викличе
виключення ``\Twig\Sandbox\SecurityError``.

.. caution::

    Теги ``extends`` та ``use`` завжди дозволені в шаблоні пісочниці. 
    Ця поведінка зміниться у версії 4.0, де ці теги потрібно буде 
    явно дозволити, як і будь-який інший тег.

Об'єкт політики є першим аргументом конструктора пісочниці::

    $sandbox = new \Twig\Extension\SandboxExtension($policy);
    $twig->addExtension($sandbox);

За замовчуванням режим пісочниці відключений і повинен бути включений при додаванні 
ненадійного коду шаблону за допомогою тегу ``sandbox``:

.. code-block:: twig

    {% sandbox %}
        {% include 'user.html' %}
    {% endsandbox %}

Ви можете пропісочити всі шаблони, передавши ``true`` як другий аргумент 
конструктора розширення::

    $sandbox = new \Twig\Extension\SandboxExtension($policy, true);

Розширення Profiler
~~~~~~~~~~~~~~~~~~~

Розширення ``profiler`` вмикає профілювальник для шаблонів Twig; його слід 
використовувати лише на ваших машинах для розробки, оскільки воно додає певні додаткові витрати::

    $profile = new \Twig\Profiler\Profile();
    $twig->addExtension(new \Twig\Extension\ProfilerExtension($profile));

    $dumper = new \Twig\Profiler\Dumper\TextDumper();
    echo $dumper->dump($profile);

Профіль містить інформацію про витрати часу та пам'яті на для шаблону, 
блоків і макросів.

Ви також можете скинути дані у сумісному з `Blackfire.io <https://blackfire.io/>`_
форматі::

    $dumper = new \Twig\Profiler\Dumper\BlackfireDumper();
    file_put_contents('/path/to/profile.prof', $dumper->dump($profile));

Завантажте профіль для його візуалізації (спочатку створіть `безкоштовний акаунт 
<https://blackfire.io/signup?utm_source=twig&utm_medium=doc&utm_campaign=profiler>`_):

.. code-block:: sh

    blackfire --slot=7 upload /path/to/profile.prof

Розширення Optimizer
~~~~~~~~~~~~~~~~~~~~

Розширення ``optimizer`` оптимізує дерево вузлів перед компіляцією::

    $twig->addExtension(new \Twig\Extension\OptimizerExtension());

За замовчуванням усі оптимізації ввімкнено. Ви можете вибрати ті, які хочете включити, передавши їх конструктору::

    $optimizer = new \Twig\Extension\OptimizerExtension(\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_FOR);

    $twig->addExtension($optimizer);

Twig підтримує наступні оптимізації:

* ``\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_ALL``, вмикає всі оптимізації (це є
  значенням за замовчуванням).

* ``\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_NONE``, вимикає усі оптимізації. 
  Це зменшує час компіляції, але може збільшити час виконання та спожиту памʼять.

* ``\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_FOR``, оптимізує тег ``for`` шляхом
  видалення створення змінної ``loop``, коли це можливо.

Виключення
----------

Twig може викликати виключення:

* ``\Twig\Error\Error``: Базове виключення для всіх помилок.

* ``\Twig\Error\SyntaxError``: Викликається, щоб сказати користувачу, що є проблема з синтаксисом шаблону.

* ``\Twig\Error\RuntimeError``: Викликається, коли виникає помилка під час виконання (наприклад,
  коли фільтр не існує).

* ``\Twig\Error\LoaderError``: Викликається, коли помилка виникає під час завантаження шаблону.

* ``\Twig\Sandbox\SecurityError``: Викликається, коли викликається недозволений тег, фільтр або
  метод у пропісоченому шаблоні.
