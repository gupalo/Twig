Рецепти
=======

.. _deprecation-notices-uk:

Відображення сповіщень про застарівання
---------------------------------------

Застарілі функції генерують повідомлення про застарівання (за допомогою виклику
PHP-функції ``trigger_error()`` ). За замовчуванням вони замовчуються і ніколи не
не відображаються і не записуються в лог.

Щоб видалити всі застарілі функції з ваших шаблонів, напишіть і запустіть скрипт
приблизно такого вигляду::

    require_once __DIR__.'/vendor/autoload.php';

    $twig = create_your_twig_env();

    $deprecations = new \Twig\Util\DeprecationCollector($twig);

    print_r($deprecations->collectDir(__DIR__.'/templates'));

Метод ``collectDir()`` компілює всі шаблони, знайдені у каталозі, відловлює повідомлення
про застарівання та повертає їх.

.. tip::

    Якщо ваші шаблони не зберігаються у файловій системі, використовуйте метод 
    ``collect()`` натомість. ``collect()`` приймає ``Traversable``, який має повернути
    імена шаблонів як ключі і зміст шаблонів як значення (як це робиться за допомогою
    ``\Twig\Util\TemplateDirIterator``).

Однак, цей код не знайде всіх застарівань (наприклад, використання деяких застарілих класів
Twig). Щоб відловлювати всі сповіщення, зареєструйте користувацький обробник помилок на 
кшталт того, що наведено нижче::

    $deprecations = [];
    set_error_handler(function ($type, $msg) use (&$deprecations) {
        if (E_USER_DEPRECATED === $type) {
            $deprecations[] = $msg;
        }
    });

    // запустіть ваш додаток

    print_r($deprecations);

Зверніть увагу, що більшість сповіщень про застарівання спрацьовують під час **компіляції**, тому 
вони не будуть згенеровані, коли шаблони вже кешовані.

.. tip::

    Якщо ви хочете керувати сповіщеннями про застарівання у ваших тестах PHPUnit, 
    погляньте на пакет `symfony/phpunit-bridge <https://github.com/symfony/phpunit-bridge>`_,
    який полегшує процес.

Робимо макет умовним
--------------------

Робота з Ajax означає, що один і той самий зміст іноді відображається як є,
а іноді прикрашається макетом. Оскільки іменами шаблонів макетів Twig можуть бути
будь-які допустимі вирази, ви можете передати змінну, яка отримає значення ``true``, коли
запит зроблено через Ajax, і відповідно до цього обрати макет:

.. code-block:: twig

    {% extends request.ajax ? "base_ajax.html" : "base.html" %}

    {% block content %}
        Це зміст для відображення.
    {% endblock %}

Робимо включення динамічним
---------------------------

При включенні шаблону його ім'я не обов'язково має бути рядком. Наприклад, назва
може залежати від значення змінної:

.. code-block:: twig

    {% include var ~ '_foo.html' %}

Якщо ``var`` оцінюється як ``index``, буде відображено шаблон ``index_foo.html``.

Насправді, ім'я шаблону може бути будь-яким валідним виразом, наприклад
наступним:

.. code-block:: twig

    {% include var|default('index') ~ '_foo.html' %}

Перевизначення шаблону, який також розширюється
-----------------------------------------------

Шаблон можна налаштувати двома різними способами:

* *Успадкування*: Шаблон *розширює* батьківський шаблон і перевизначає деякі
  блоки;

* *Заміна*: Якщо ви використовуєте завантажувач файлової системи, Twig завантажує перший
  шаблон, який він знайде у списку сконфігурованих каталогів; шаблон, знайдений у каталозі,
  *замінює* інший шаблон з каталогу, розташованого далі у списку.

Але як поєднати обидва варіанти: *замінити* шаблон, який також розширюється
(тобто, шаблон у каталозі, розташованому далі у списку)?

Припустимо, що ваші шаблони завантажуються як з папки ``.../templates/mysite``, так і 
з папки ``.../templates/default`` в такому порядку. Шаблон ``page.twig``,
що зберігається в ``.../templates/default``, читається наступним чином:

.. code-block:: twig

    {# page.twig #}
    {% extends "layout.twig" %}

    {% block content %}
    {% endblock %}

Ви можете замінити цей шаблон, помістивши файл з таким же ім'ям в папку ``.../templates/mysite``.
А якщо ви хочете розширити оригінальний шаблон, вам може кортіти  написати наступне:

.. code-block:: twig

    {# page.twig in .../templates/mysite #}
    {% extends "page.twig" %} {# from .../templates/default #}

Однак, це не працюватиме, так як Twig завжди завантажуватиме шаблон з
``.../templates/mysite``.

Виявляється, можна змусити це працювати, додавши каталог прямо в кінці ваших каталогів шаблонів,
який є батьківським для всіх інших каталогів: ``.../templates`` у нашому випадку. Це призведе 
до того, що зробить кожен файл шаблону у нашій системі унікально адресованим. Більшість часу ви 
будете використовувати "нормальні" шляхи, але в особливих випадках, коли ви захочете розширити
шаблон за допомогою розширити шаблон з перевизначеною версією його самого, ми можемо послатися 
на його повний, однозначний шлях до шаблону у тегу розширення:

.. code-block:: twig

    {# page.twig in .../templates/mysite #}
    {% extends "default/page.twig" %} {# from .../templates #}

.. note::

    Цей рецепт був натхненний наступною вікі-сторінкою Django:
    https://code.djangoproject.com/wiki/ExtendingTemplates

Налаштування синтаксису
-----------------------

Twig дозволяє деяке налаштування синтаксису для роздільників блоків. Не рекомендується
використовувати цю можливість, оскільки шаблони будуть прив'язані до вашого користувацького
синтаксису. Але для певних проектів може мати сенс змінити значення за замовчуванням.

Щоб змінити роздільники блоків, вам потрібно створити власний об'єкт лексера::

    $twig = new \Twig\Environment(...);

    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'   => ['{#', '#}'],
        'tag_block'     => ['{%', '%}'],
        'tag_variable'  => ['{{', '}}'],
        'interpolation' => ['#{', '}'],
    ]);
    $twig->setLexer($lexer);

Нижче наведено приклад конфігурації, що імітує деякий інший синтексис движку шаблонів::

    // Синтаксис Ruby erb
    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'  => ['<%#', '%>'],
        'tag_block'    => ['<%', '%>'],
        'tag_variable' => ['<%=', '%>'],
    ]);

    // Синтаксис SGML Comment
    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'  => ['<!--#', '-->'],
        'tag_block'    => ['<!--', '-->'],
        'tag_variable' => ['${', '}'],
    ]);

    // Схожий на Smarty
    $lexer = new \Twig\Lexer($twig, [
        'tag_comment'  => ['{*', '*}'],
        'tag_block'    => ['{', '}'],
        'tag_variable' => ['{$', '}'],
    ]);

Використання динамічних властивостей обʼєкта
--------------------------------------------

Коли Twig зустрічає змінну типу ``article.title``, він намагається знайти в об'єкті 
``article`` публічну властивість властивість ``title``.

Це також працює, якщо властивість не існує, а визначається динамічно,
завдяки магічному методу ``__get()``; вам також потрібно реалізувати магічний метод
``__isset()``, як показано у наступному фрагменті коду::

    class Article
    {
        public function __get($name)
        {
            if ('title' == $name) {
                return 'The title';
            }

            // викликати якусь помилку
        }

        public function __isset($name)
        {
            if ('title' == $name) {
                return true;
            }

            return false;
        }
    }

Доступ до батьківського контексту у вкладених циклах
----------------------------------------------------

Іноді при використанні вкладених циклів вам потрібно отримати доступ до батьківського
контексту. Батьківський контекст завжди доступний через змінну ``loop.parent``. Наприклад,
якщо у вас є такі дані шаблону::

    $data = [
        'topics' => [
            'topic1' => ['Message 1 of topic 1', 'Message 2 of topic 1'],
            'topic2' => ['Message 1 of topic 2', 'Message 2 of topic 2'],
        ],
    ];


І наступний шаблон для відображення всіх повідомлень у всіх темах:

.. code-block:: twig

    {% for topic, messages in topics %}
        * {{ loop.index }}: {{ topic }}
      {% for message in messages %}
          - {{ loop.parent.loop.index }}.{{ loop.index }}: {{ message }}
      {% endfor %}
    {% endfor %}

Виведення буде схожим на:

.. code-block:: text

    * 1: topic1
      - 1.1: Повідомлення 1 теми 1
      - 1.2: Повідомлення 2 теми 1
    * 2: topic2
      - 2.1: Повідомлення 1 теми 2
      - 2.2: Повідомлення 2 теми 2

У внутрішньому циклі змінна ``loop.parent`` використовується для доступу до зовнішнього
контексту. Отже, індекс поточної ``topic``, визначений зовні для цилку, доступний через
змінну ``loop.parent.loop.index``.

Визначення невизначених функцій, фільтрів і тегів на ходу
---------------------------------------------------------

.. versionadded:: 3.2

    Метод ``registerUndefinedTokenParserCallback()`` було представлено в Twig
    3.2.

Якщо функцію/фільтр/тег не визначено, за замовчуванням Twig викликає виключення
``\Twig\Error\SyntaxError``. Однак, він також може викликати `callback`_(будь-яке
допустиме PHP-викличне), який має повернути функцію/фільтр/тег.

Для тегів реєструйте зворотні виклики за допомогою ``registerUndefinedTokenParserCallback()``.
Для фільтрів зареєструйте зворотні виклики за допомогою ``registerUndefinedFilterCallback()``.
Для функцій використовуйте ``registerUndefinedFunctionCallback()``::

    // автоматично реєструвати всі нативні функції PHP як функції Twig
    // НІКОЛИ не робіть цього в проєкті, так як це НЕ є безпечним
    $twig->registerUndefinedFunctionCallback(function ($name) {
        if (function_exists($name)) {
            return new \Twig\TwigFunction($name, $name);
        }

        return false;
    });

Якщо викличне не може повернути коректну функцію/фільтр/тег, воно повинно
повернути ``false``.

Якщо ви зареєструєте більше одного зворотного виклику, Twig буде викликати їх по черзі,
доки один з них не поверне ``false``.

.. tip::

    Оскільки розвʼязання функцій/фільтрів/тегів відбувається під час компіляції,
    реєстрація цих зворотних викликів не спричиняє жодних додаткових витрат.

Валідація синтаксису шаблону
----------------------------

Коли код шаблону надається третьою стороною (наприклад, через веб-інтерфейс), може бути
корисно перевірити синтаксис шаблону перед його збереженням. Якщо код шаблону зберігається
у змінній ``$template``, ось як це можна зробити::

    try {
        $twig->parse($twig->tokenize(new \Twig\Source($template)));

        // $template є валідним
    } catch (\Twig\Error\SyntaxError $e) {
        // $template містить одну або більше помилок синтаксису
    }

Якщо ви виконуєте ітерацію за набором файлів, ви можете передати ім'я файлу методу
``tokenize()``, щоб отримати ім'я файлу у повідомленні виключення::

    foreach ($files as $file) {
        try {
            $twig->parse($twig->tokenize(new \Twig\Source($template, $file->getFilename(), $file)));

            // $template є валідним
        } catch (\Twig\Error\SyntaxError $e) {
            // $template містить одну або більше помилок синтаксису
        }
    }

.. note::

    Цей метод не виявить жодних порушень політики пісочниці, оскільки політика
    застосовується під час відображення шаблону ( так як Twig потребує контексту
    для деяких перевірок, таких як дозволені методи в об'єктах).

Оновлення змінених щаблонів при ввімкненому OPcache
---------------------------------------------------

При використанні OPcache з ``opcache.validate_timestamps``, встановленим у значення ``0``,
увімкнено кеш Twig і вимкнено автоматичне перезавантаження, що очищає кеш шаблону, і він
не буде оновлюватися.

Щоб обійти це, змусьте Twig зробити кеш байт-коду невалідним::

    $twig = new \Twig\Environment($loader, [
        'cache' => new \Twig\Cache\FilesystemCache('/some/cache/path', \Twig\Cache\FilesystemCache::FORCE_BYTECODE_INVALIDATION),
        // ...
    ]);

Повторне використання відвідувача вузла зі станом
-------------------------------------------------

При приєднанні відвідувача до екземпляра ``\Twig\Environment``, Twig використовує його
для для відвідування *усіх* шаблонів, які він компілює. Якщо вам потрібно зберегти деяку
інформацію про стан, ви, ймовірно, захочете обнуляти її при відвідуванні нового шаблону.

Цього можна досягти за допомогою наступного коду::

    protected $someTemplateState = [];

    public function enterNode(\Twig\Node\Node $node, \Twig\Environment $env)
    {
        if ($node instanceof \Twig\Node\ModuleNode) {
            // обнулити стан, так як ми входимо у новий шаблон
            $this->someTemplateState = [];
        }

        // ...

        return $node;
    }

Використання бази даних для зберігання шаблонів
-----------------------------------------------

Якщо ви розробляєте CMS, шаблони зазвичай зберігаються в базі даних. Цей рецепт 
дає вам простий завантажувач шаблонів PDO, який ви можете використовувати як відправну
точку для свого власного.

Спочатку створимо тимчасову базу даних SQLite3 в пам'яті для роботи::

    $dbh = new PDO('sqlite::memory:');
    $dbh->exec('CREATE TABLE templates (name STRING, source STRING, last_modified INTEGER)');
    $base = '{% block content %}{% endblock %}';
    $index = '
    {% extends "base.twig" %}
    {% block content %}Hello {{ name }}{% endblock %}
    ';
    $now = time();
    $dbh->prepare('INSERT INTO templates (name, source, last_modified) VALUES (?, ?, ?)')->execute(['base.twig', $base, $now]);
    $dbh->prepare('INSERT INTO templates (name, source, last_modified) VALUES (?, ?, ?)')->execute(['index.twig', $index, $now]);

Ми створили просту таблицю ``templates``, яка містить два шаблони:
``base.twig`` та ``index.twig``.

Тепер давайте визначимо завантажувач, який може використовувати цю базу даних::

    class DatabaseTwigLoader implements \Twig\Loader\LoaderInterface
    {
        protected $dbh;

        public function __construct(PDO $dbh)
        {
            $this->dbh = $dbh;
        }

        public function getSourceContext(string $name): Source
        {
            if (false === $source = $this->getValue('source', $name)) {
                throw new \Twig\Error\LoaderError(sprintf('Template "%s" does not exist.', $name));
            }

            return new \Twig\Source($source, $name);
        }

        public function exists(string $name)
        {
            return $name === $this->getValue('name', $name);
        }

        public function getCacheKey(string $name): string
        {
            return $name;
        }

        public function isFresh(string $name, int $time): bool
        {
            if (false === $lastModified = $this->getValue('last_modified', $name)) {
                return false;
            }

            return $lastModified <= $time;
        }

        protected function getValue($column, $name)
        {
            $sth = $this->dbh->prepare('SELECT '.$column.' FROM templates WHERE name = :name');
            $sth->execute([':name' => (string) $name]);

            return $sth->fetchColumn();
        }
    }

Нарешті, оць приклад того, як ви можете це використовувати::

    $loader = new DatabaseTwigLoader($dbh);
    $twig = new \Twig\Environment($loader);

    echo $twig->render('index.twig', ['name' => 'Fabien']);

Використання різних джерел шаблонів
-----------------------------------

Цей рецепт є продовженням попереднього. Навіть якщо ви зберігаєте надіслані шаблони в базі
даних, ви, можливо, захочете зберегти оригінальні/базові шаблони у файловій системі. Якщо
шаблони можна завантажувати з різних джерел, вам слід скористатися завантажувачем 
``\Twig\Loader\ChainLoader``.

Як ви можете бачити у попередньому рецепті, ми посилаємося на шаблон так само, як це було
б зроблено за допомогою звичайного завантажувача файлової системи. Це є ключем до можливості
змішувати різні шаблони, що надходять з бази даних, файлової системи або будь-якого іншого
завантажувача: ім'я шаблону має бути логічним ім'ям, а не шляхом з файлової системи::

    $loader1 = new DatabaseTwigLoader($dbh);
    $loader2 = new \Twig\Loader\ArrayLoader([
        'base.twig' => '{% block content %}{% endblock %}',
    ]);
    $loader = new \Twig\Loader\ChainLoader([$loader1, $loader2]);

    $twig = new \Twig\Environment($loader);

    echo $twig->render('index.twig', ['name' => 'Fabien']);

Тепер, коли шаблони ``base.twig`` визначено у завантажувачі масиву, ви можете
видалити його з бази даних, і все інше буде працювати як і раніше.

Завантаження шаблону з рядка
----------------------------

З шаблону можна завантажити шаблон, що зберігається у рядку, за допомогою функції
``template_from_string`` (через розширення ``\Twig\Extension\StringLoaderExtension``):

.. code-block:: twig

    {{ include(template_from_string("Hello {{ name }}")) }}

З PHP також можна завантажити шаблон, збережений у вигляді рядка, за допомогою
``\Twig\Environment::createTemplate()``::

    $template = $twig->createTemplate('hello {{ name }}');
    echo $template->render(['name' => 'Fabien']);

Використання Twig та AngularJS в одному шаблоні
-----------------------------------------------

Змішування різних синтаксисів шаблонів в одному файлі не рекомендується,
оскільки AngularJS та Twig використовують однакові роздільники у своєму синтаксисі:
``{{`` та ``}}``.

Проте, якщо ви хочете використовувати AngularJS і Twig в одному шаблоні, є
два способи зробити так, щоб це працювало, залежно від кількості AngularJS,
яку вам потрібно додати до ваших шаблонів:

* Екранування роздільників AngularJS шляхом обгортання розділів AngularJS тегом
  ``{% verbatim %}`` або екрануванням кожного роздільника через ``{{ '{{' }}`` та
  ``{{ '}}' }}``;

* Зміна роздільників одного з движків шаблонів (залежно від того, який з них ви ввели
  останнім): 

  * Для AngularJS, змініть теги інтерполяції, використовуючи сервіс
    ``interpolateProvider``, наприклад, під час ініціалізації модуля:

    .. code-block:: javascript

        angular.module('myApp', []).config(function($interpolateProvider) {
            $interpolateProvider.startSymbol('{[').endSymbol(']}');
        });

  * Для Twig, змініть роздільники через опцію лексера ``tag_variable``::

        $env->setLexer(new \Twig\Lexer($env, [
            'tag_variable' => ['{[', ']}'],
        ]));

Позначення вузла як безпечного
------------------------------

При використанні розширення екранування ви можете позначити деякі вузли як
як безпечні, щоб уникнути будь-якого екранування. Ви можете зробити це, обгорнувши
ваш вираз за допомогою вузла ``RawFilter``::

    use Twig\Node\Expression\Filter\RawFilter;

    $safeExpr = new RawFilter(new YourSafeNode());

.. _callback: https://www.php.net/manual/en/function.is-callable.php
