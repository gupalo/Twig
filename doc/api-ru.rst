Twig для разработчиков
======================

Эта глава описывает API к Twig, а не язык шаблонов. Она будет наиболее полезна в качестве справочника для тех, кто реализует интерфейс шаблонов в приложении, а не для тех,
кто создает шаблоны Twig.

Основы
------

Twig использует центральный объект, называемый **окружение** (класс
``\Twig\Environment``). Экземпляры этого класса используются для хранения
конфигурации и расширений, а также для загрузки шаблонов.

Большинство приложений создают один объект ``\Twig\Environment`` во время инициализации
приложения и используют его для загрузки шаблонов. В некоторых случаях может быть
полезно иметь несколько окружений бок о бок с различными конфигурациями.

Типичный способ конфигурации Twig для загрузки шаблонов для приложения выглядит
примерно так::

    require_once '/path/to/vendor/autoload.php';

    $loader = new \Twig\Loader\FilesystemLoader('/path/to/templates');
    $twig = new \Twig\Environment($loader, [
        'cache' => '/path/to/compilation_cache',
    ]);

Это создаст окружение шаблонов с конфигурацией по умолчанию и загрузчиком,
который ищет шаблоны в каталоге ``/path/to/templates/``. Доступны различные загрузчики,
и вы также можете написать свой собственный, если вы хотите загружать шаблоны из базы
данных или других источников.

.. note::

    Обратите внимание, что вторым аргументом окружения является массив опций.
    Опция ``cache`` - это каталог кеша компиляции, куда Twig кеширует
    скомпилированные шаблоны, чтобы избежать фазы анализа для последующих
    запросов. Это очень отличается от кеша, который вы можете добавить для
    для обрабатываемых шаблонов. Для такой потребности вы можете использовать
    любую доступную библиотеку кеша PHP.

Отображение шаблонов
--------------------

Чтобы загрузить шаблон из окружения Twig, вызовите метод ``load()``, который
возвращает экземпляр ``\Twig\TemplateWrapper``::

    $template = $twig->load('index.html');

Чтобы отобразить шаблон с некоторыми переменными, вызовите метод ``render()``::

    echo $template->render(['the' => 'variables', 'go' => 'here']);

.. note::

    Метод ``display()`` является сокращением для вывода отображенного шаблона.

Вы также можете скачать и отобразить шаблон одним махом::

    echo $twig->render('index.html', ['the' => 'variables', 'go' => 'here']);

Если шаблон определяет блоки, их можно отобразить отдельно с помощью вызова
``renderBlock()``::

    echo $template->renderBlock('block_name', ['the' => 'variables', 'go' => 'here']);

.. _environment_options-ru:

Опции окружения
---------------

При создании нового экземпляра ``\Twig\Environment`` вы можете передать массив опций в
качестве второго аргумента конструктора::

    $twig = new \Twig\Environment($loader, ['debug' => true]);

Доступны следующие опции:

* ``debug`` *булево значение*

    Когда установлено как ``true``, сгенерированные шаблоны имеют метод
    ``__toString()``, который вы можете использовать для отображения
    сгенерированных узлов (по умолчанию ``false``).

* ``charset`` *строка* (по умолчанию - ``utf-8``)

    Набор символов, используемый шаблонами.

* ``cache`` *строка* или ``false``

    Абсолютный путь, где хранить скомпилированные шаблоны, или
    ``false`` для отключения кеширования (по умолчанию).

* ``auto_reload`` *булево значение*

    При разработке с помощью Twig полезно повторно компилировать шаблон каждый раз,
    когда изменяется исходный код. Если вы не укажете значение для опции 
    ``auto_reload``, оно будет определено автоматически на основе значения
    ``debug``.

.. _environment_options_strict_variables-ru:

* ``strict_variables`` *булево значение*

    Если установлено в значение ``false``, Twig будет молча игнорировать невалидные
    переменные (переменные и/или атрибуты/методы, которых не существует) и будет заменять
    их значением ``null``. Если установлено значение ``true``, Twig вызовет исключение (по 
    умолчанию ``false``).

* ``autoescape`` *строка*

    Устанавливает стратегию авто-экранирования по умолчанию (``name``, ``html``, ``js``,
    ``css``, ``url``, ``html_attr``, или обратный вызов PHP, который принимает "filename" шаблона 
    и возвращает стратегию экранирования для использования - обратный вызов не может быть именем 
    функции, чтобы избежать столкновения со встроенными стратегиями экранирования); установите значение
    ``false``, чтобы отключить автоматическое экранирование. Стратегия экранирования ``name`` определяет
    стратегию экранирования для шаблона на основе расширения имени файла шаблона
    (эта стратегия не вызывает никаких дополнительных затрат во время выполнения, поскольку
    автоматическое экранирование выполняется во время компиляции).

* ``optimizations`` *целое число*

    Флажок, указывающий, какие оптимизации применять (по умолчанию ``-1``
    - все оптимизации включены; установите ``0`` для того, чтобы их отключить).

Загрузчики
----------

Загрузчики отвечают за загрузку шаблонов из таких источников, как файловая система.

Кеш компиляции
~~~~~~~~~~~~~~

Все загрузчики шаблонов могут кешировать скомпилированные шаблоны в файловой системе для 
дальнейшего использования. Это значительно ускоряет работу Twig, поскольку шаблоны компилируются
только один раз.

Встроенные загрузчики
~~~~~~~~~~~~~~~~~~~~~

Вот список встроенных загрузчиков:

``\Twig\Loader\FilesystemLoader``
.................................

``\Twig\Loader\FilesystemLoader`` загружает шаблоны из файловой системы. Этот загрузчик
может находить шаблоны в папках файловой системы и является предпочтительным способом их загрузки::

    $loader = new \Twig\Loader\FilesystemLoader($templateDir);

Он также может искать шаблоны в массиве каталогов::

    $loader = new \Twig\Loader\FilesystemLoader([$templateDir1, $templateDir2]);

С такой конфигурацией Twig сначала будет искать шаблоны в ``$templateDir1``, и если
они не существуют, то будет искать их в ``$templateDir2``.

Вы можете добавлять или изменять пути с помощью методов ``addPath()`` и ``prependPath()``::

    $loader->addPath($templateDir3);
    $loader->prependPath($templateDir4);

Загрузчик файловой системы также поддерживает шаблоны с пространством имен. Это позволяет группировать
ваши шаблоны в разных пространствах имен, которые имеют собственные пути к шаблонам.

При использовании методов ``setPaths()``, ``addPath()`` и ``prependPath()``, укажите пространство
имен как второй аргумент (если оно не указано, эти методы работают с "основным" пространством имен)::

    $loader->addPath($templateDir, 'admin');

К шаблонам с пространством имен можно получить доступ через специальную нотацию
``@namespace_name/template_path``::

    $twig->render('@admin/index.html', []);

``\Twig\Loader\FilesystemLoader`` поддерживает абсолютные и относительные пути. Использование относительных
путей является предпочтительным, поскольку это делает ключи кеша независимыми от корневого каталога проекта
(например, это позволяет прогревать кеш с сервера сборки, где каталог может отличаться от того,
используемого на серверах производства)::

    $loader = new \Twig\Loader\FilesystemLoader('templates', getcwd().'/..');

.. note::

    Если не передавать корневой путь как второй аргумент, Twig использует ``getcwd()``
    для относительных путей.

``\Twig\Loader\ArrayLoader``
............................

``\Twig\Loader\ArrayLoader`` загружает шаблон из массива PHP. Ему передается
массив строк, привязанных к названиям шаблонов::

    $loader = new \Twig\Loader\ArrayLoader([
        'index.html' => 'Hello {{ name }}!',
    ]);
    $twig = new \Twig\Environment($loader);

    echo $twig->render('index.html', ['name' => 'Fabien']);

Этот загрузчик очень полезен для модульного тестирования. Он также может быть использован 
для небольших проектов, где хранение всех шаблонов в одном PHP-файле может иметь смысл.

.. tip::

    При использовании загрузчика ``Array`` с механизмом кеширования следует знать, что
    новый ключ кеша генерируется каждый раз, когда содержание шаблона "изменяется" (ключ
    кеша является исходным кодом шаблона). Если вы не хотите, чтобы ваш кеш вышел из-под
    контроля, вам нужно позаботиться об очистке старого файла кеша самостоятельно.

``\Twig\Loader\ChainLoader``
............................

``\Twig\Loader\ChainLoader`` делегирует загрузку шаблонов другим загрузчикам::

    $loader1 = new \Twig\Loader\ArrayLoader([
        'base.html' => '{% block content %}{% endblock %}',
    ]);
    $loader2 = new \Twig\Loader\ArrayLoader([
        'index.html' => '{% extends "base.html" %}{% block content %}Hello {{ name }}{% endblock %}',
        'base.html'  => 'Will never be loaded',
    ]);

    $loader = new \Twig\Loader\ChainLoader([$loader1, $loader2]);

    $twig = new \Twig\Environment($loader);

При поиске шаблона Twig пробует каждый загрузчик по очереди и возвращается, как только
шаблон будет найден. При отображении шаблона ``index.html`` из приведенного выше
примера, Twig загрузит его с помощью ``$loader2``, но шаблон ``base.html``
будет загружен из ``$loader1``.

.. note::

    Вы также можете добавлять загрузчики через метод ``addLoader()``.

Создайте ваш собственный загрузчик
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Все загрузчики реализуют ``\Twig\Loader\LoaderInterface``::

    interface \Twig\Loader\LoaderInterface
    {
        /**
         * Возвращает контекст источника для заданного логического имени шаблона.
         *
         * @param string $name Логічне імʼя шаблону
         *
         * @return \Twig\Source
         *
         * @throws \Twig\Error\LoaderError Коли $name не знайдено
         */
        public function getSourceContext($name);

        /**
         * Получает ключ кеша для использования для кеша заданного имени шаблона.
         *
         * @param string $name Імя шаблона для загрузки
         *
         * @return string Ключ кешу
         *
         * @throws \Twig\Error\LoaderError Когда $name не найден
         */
        public function getCacheKey($name);

        /**
         * Возвращает true, если шаблон все еще свежий.
         *
         * @param string    $name Імя шаблона
         * @param timestamp $time Время последней модификации кешированного шаблона
         *
         * @return bool    true, если шаблон свежий, false - в другом случае
         *
         * @throws \Twig\Error\LoaderError Когда $name не найден
         */
        public function isFresh($name, $time);

        /**
         * Проверить, есть ли у нас исходный код шаблона, имея его имя.
         *
         * @param string $name Имя шаблона для проверки того, можем ли мы его загрузить
         *
         * @return bool    Обрабатывается ли исходный код шаблона загрузчиком
         */
        public function exists($name);
    }

Метод ``isFresh()`` должен возвращать ``true``, если текущий кешированный шаблон
все еще свежий, учитывая время последней модификации, или ``false`` в противном случае.

Метод ``getSourceContext()`` должен возвращать экземпляр ``\Twig\Source``.

Использование расширений
------------------------

Расширения Twig - это пакеты, которые добавляют новые возможности к Twig. Зарегистрируйте расширение
с помощью метода ``addExtension()``::

    $twig->addExtension(new \Twig\Extension\SandboxExtension());

Twig поставляется со следующими расширениями:

* *Twig\Extension\CoreExtension*: Определяет все основные функции Twig.

* *Twig\Extension\DebugExtension*: Определяет функцию ``dump``, чтобы помочь с отладкой
  переменных шаблона.

* *Twig\Extension\EscaperExtension*: Добавляет автоматическое экранирование вывода и возможность
  экранировать/не экранировать блоки кода.

* *Twig\Extension\SandboxExtension*: Добавляет режим песочницы в среду Twig по умолчанию,
  что делает оценку ненадежного кода безопасной.

* *Twig\Extension\ProfilerExtension*: Включает встроенный профилировщик Twig.

* *Twig\Extension\OptimizerExtension*: Оптимизирует дерево узлов перед компиляцией.

* *Twig\Extension\StringLoaderExtension*: Определяет функцию ``template_from_string``, чтобы
  позволить загружать шаблоны из строки в шаблоне.

Расширения Core, Escaper, и Optimizer регистрируются по умолчанию.

Встроенные расширения
---------------------

Этот раздел описывает функции, добавляемые встроенными расширениями.

.. tip::

    Прочитайте главу о :doc:`расширения Twig <advanced>`, чтобы узнать, как
    создавать ваши собственные расширения.

Основные расширения
~~~~~~~~~~~~~~~~~~~

``core`` Расширение определяет все основные функции Twig:

* :doc:`Теги <tags/index>`;
* :doc:`Фильтры <filters/index>`;
* :doc:`Функции <functions/index>`;
* :doc:`Тесты <tests/index>`.

Расширение Escaper
~~~~~~~~~~~~~~~~~~

Расширение ``escaper`` добавляет в Twig автоматическое экранирование вывода. Оно определяет тег
тег ``autoescape`` и фильтр ``raw``.

При создании расширения экранирования вы можете включить или выключить глобальную
стратегию экранирования вывода::

    $escaper = new \Twig\Extension\EscaperExtension('html');
    $twig->addExtension($escaper);

Если установлено в значение ``html``, все переменные в шаблонах экранируются (с помощью
стратегии экранирования ``html``), кроме тех, которые используют фильтр ``raw``:

.. code-block:: twig

    {{ article.to_html|raw }}

Вы также можете изменить режим экранирования локально с помощью тега ``autoescape``:

.. code-block:: twig

    {% autoescape 'html' %}
        {{ var }}
        {{ var|raw }}      {# var не будет экранирован #}
        {{ var|escape }}   {# var не будет экранирован дважды #}
    {% endautoescape %}

.. warning::

    Тег ``autoescape`` не имеет никакого эффекта на включенные файлы.

Правила экранирования реализованы следующим образом:

* Литералы (целые числа, булевы, массивы, ...), используемые в шаблоне непосредственно как 
  переменные или аргументы фильтров, никогда не экранируются автоматически:

  .. code-block:: html+twig

        {{ "Twig<br/>" }} {# не буде екрановано #}

        {% set text = "Twig<br/>" %}
        {{ text }} {# will be escaped #}

* Выражения, результатом которых является литерал или переменная, помеченные как безопасные, 
  никогда не экранируются автоматически:

  .. code-block:: html+twig

        {{ foo ? "Twig<br/>" : "<br/>Twig" }} {# won't be escaped #}

        {% set text = "Twig<br/>" %}
        {{ true ? text : "<br/>Twig" }} {# будет экранировано #}
        {{ false ? text : "<br/>Twig" }} {# не будет экранировано #}

        {% set text = "Twig<br/>" %}
        {{ foo ? text|raw : "<br/>Twig" }} {# не будет экранировано #}

* Объекты с методом ``__toString`` конвертируются в строки и 
  экранируются. Вы можете пометить некоторые классы и/или интерфейсы как безопасные для
  некоторых стратегий с помощью ``EscaperExtension::addSafeClass()``:

  .. code-block:: twig

        // обозначить объект класса Foo как безопасный для стратегии HTML
        $escaper->addSafeClass('Foo', ['html']);

        // обозначить объект интерфейса Foo как безопасный для стратегии HTML
        $escaper->addSafeClass('FooInterface', ['html']);

        // обозначить объект класса Foo как безопасный для стратегий HTML и JS
        $escaper->addSafeClass('Foo', ['html', 'js']);

        // обозначить объект класса Foo как безопасный для всех стратегий
        $escaper->addSafeClass('Foo', ['all']);

* Экранирование применяется перед выводом, после применения любого другого фильтра:

  .. code-block:: twig

        {{ var|upper }} {# эквивалентно {{ var|upper|escape }} #}

* Фильтр ``raw`` следует использовать только в конце цепочки фильтров:

  .. code-block:: twig

        {{ var|raw|upper }} {# будет экранировано #}

        {{ var|upper|raw }} {# не будет экранировано #}

* Автоматическое экранирование не применяется, если последний фильтр в цепочке помечен как
  безопасным для текущего контекста (например, ``html`` или ``js``). ``escape`` и
  ``escape('html')`` помечены как безопасные для HTML, ``escape('js')`` помечен
  безопасным для JavaScript, ``raw`` - безопасным для всего.

  .. code-block:: twig

        {% autoescape 'js' %}
            {{ var|escape('html') }} {# будет экранировано для HTML и JavaScript #}
            {{ var }} {# будет экранировано для JavaScript #}
            {{ var|escape('js') }} {# не будет экранировано дважды #}
        {% endautoescape %}

.. note::

    Обратите внимание, что автоматическое экранирование имеет некоторые ограничения,
    поскольку экранирование применяется в выражениях после вычисления. Например, при
    работе с конкатенацией, ``{{ foo|raw ~ bar }}`` не даст ожидаемого результата, 
    поскольку экранирование применяется к результату конкатенации, а не к отдельным 
    переменным (следовательно, фильтр ``raw`` здесь не будет иметь никакого эффекта).

Расширение Sandbox
~~~~~~~~~~~~~~~~~~

Расширение ``sandbox`` можно использовать для оценки ненадежного кода. Доступ к
опасным атрибутам и методам запрещен. Безопасностью песочницы управляет
экземпляр политики. По умолчанию Twig поставляется с одним классом политики:
``\Twig\Sandbox\SecurityPolicy``. Этот класс позволяет вам вносить в белый список некоторые
теги, фильтры, функции, свойства и методы::

    $tags = ['if'];
    $filters = ['upper'];
    $methods = [
        'Article' => ['getTitle', 'getBody'],
    ];
    $properties = [
        'Article' => ['title', 'body'],
    ];
    $functions = ['range'];
    $policy = new \Twig\Sandbox\SecurityPolicy($tags, $filters, $methods, $properties, $functions);

В предыдущей конфигурации политика безопасности будет разрешать использование только
тега ``if`` и фильтра ``upper``. Кроме того, шаблоны смогут 
вызывать методы ``getTitle()`` и ``getBody()`` только в объектах ``Article``, а
также публичных свойствах ``title`` и ``body``. Все остальное будет запрещено и вызовет
исключение ``\Twig\Sandbox\SecurityError``.

.. caution::

    Теги ``extends`` и ``use`` всегда разрешены в шаблоне песочницы. 
    Это поведение изменится в версии 4.0, где эти теги нужно будет 
    явно разрешить, как и любой другой тег.

Объект политики является первым аргументом конструктора песочницы::

    $sandbox = new \Twig\Extension\SandboxExtension($policy);
    $twig->addExtension($sandbox);

По умолчанию режим песочницы отключен и должен быть включен при добавлении 
ненадежного кода шаблона с помощью тега ``sandbox``:

.. code-block:: twig

    {% sandbox %}
        {% include 'user.html' %}
    {% endsandbox %}

Вы можете прописать все шаблоны, передав ``true`` в качестве второго аргумента 
конструктора расширения::

    $sandbox = new \Twig\Extension\SandboxExtension($policy, true);

Расширение Profiler
~~~~~~~~~~~~~~~~~~~

Расширение ``profiler`` включает профилировщик для шаблонов Twig; его следует 
использовать только на ваших машинах для разработки, поскольку это добавляет некоторые
дополнительные расходы::

    $profile = new \Twig\Profiler\Profile();
    $twig->addExtension(new \Twig\Extension\ProfilerExtension($profile));

    $dumper = new \Twig\Profiler\Dumper\TextDumper();
    echo $dumper->dump($profile);

Профиль содержит информацию о затратах времени и памяти на для шаблона, 
блоков и макросов.

Вы также можете сбросить данные в совместимом с `Blackfire.io <https://blackfire.io/>`_
формате::

    $dumper = new \Twig\Profiler\Dumper\BlackfireDumper();
    file_put_contents('/path/to/profile.prof', $dumper->dump($profile));

Загрузите профиль для его визуализации (сначала создайте `бесплатный аккаунт`. 
<https://blackfire.io/signup?utm_source=twig&utm_medium=doc&utm_campaign=profiler>`_):

.. code-block:: sh

    blackfire --slot=7 upload /path/to/profile.prof

Расширение Optimizer
~~~~~~~~~~~~~~~~~~~~

Расширение ``optimizer`` оптимизирует дерево узлов перед компиляцией::

    $twig->addExtension(new \Twig\Extension\OptimizerExtension());

По умолчанию все оптимизации включены. Вы можете выбрать те, которые хотите включить, передав их конструктору::

    $optimizer = new \Twig\Extension\OptimizerExtension(\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_FOR);

    $twig->addExtension($optimizer);

Twig поддерживает следующие оптимизации:

* ``\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_ALL``, включает все оптимизации (это является
  значением по умолчанию).

* ``\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_NONE``, отключает все оптимизации. 
  Это уменьшает время компиляции, но может увеличить время выполнения и потребляемую память.

* ``\Twig\NodeVisitor\OptimizerNodeVisitor::OPTIMIZE_FOR``, оптимизирует тег ``for`` путем
  удаления создания переменной ``loop``, когда это возможно.

Исключения
----------

Twig может вызвать исключения:

* ``\Twig\Error\Error``: Базовое исключение для всех ошибок.

* ``\Twig\Error\SyntaxError``: Вызывается, чтобы сказать пользователю, что есть проблема с синтаксисом шаблона.

* ``\Twig\Error\RuntimeError``: Вызывается, когда возникает ошибка во время выполнения (например,
  когда фильтр не существует).

* ``\Twig\Error\LoaderError``: Вызывается, когда ошибка возникает во время загрузки шаблона.

* ``\Twig\Sandbox\SecurityError``: Вызывается, когда вызывается неразрешенный тег, фильтр или
  метод в шаблоне, пропущенном через песочницу.
